(self.webpackChunkhra_ui=self.webpackChunkhra_ui||[]).push([[792],{"./libs/components/organisms lazy recursive ^\\.\\/.*$ include: (?%21.*node_modules)(?:\\/libs\\/components\\/organisms(?:\\/(?%21\\.)(?:(?:(?%21(?:^%7C\\/)\\.).)*?)\\/%7C\\/%7C$)(?%21\\.)(?=.)[^/]*?\\.mdx)$":module=>{function webpackEmptyAsyncContext(req){return Promise.resolve().then((()=>{var e=new Error("Cannot find module '"+req+"'");throw e.code="MODULE_NOT_FOUND",e}))}webpackEmptyAsyncContext.keys=()=>[],webpackEmptyAsyncContext.resolve=webpackEmptyAsyncContext,webpackEmptyAsyncContext.id="./libs/components/organisms lazy recursive ^\\.\\/.*$ include: (?%21.*node_modules)(?:\\/libs\\/components\\/organisms(?:\\/(?%21\\.)(?:(?:(?%21(?:^%7C\\/)\\.).)*?)\\/%7C\\/%7C$)(?%21\\.)(?=.)[^/]*?\\.mdx)$",module.exports=webpackEmptyAsyncContext},"./libs/components/organisms lazy recursive ^\\.\\/.*$ include: (?%21.*node_modules)(?:\\/libs\\/components\\/organisms(?:\\/(?%21\\.)(?:(?:(?%21(?:^%7C\\/)\\.).)*?)\\/%7C\\/%7C$)(?%21\\.)(?=.)[^/]*?\\.stories\\.(js%7Cjsx%7Cts%7Ctsx))$":(module,__unused_webpack_exports,__webpack_require__)=>{var map={"./src/lib/biomarker-table/biomarker-table.component.stories":["./libs/components/organisms/src/lib/biomarker-table/biomarker-table.component.stories.ts",722,967],"./src/lib/biomarker-table/biomarker-table.component.stories.ts":["./libs/components/organisms/src/lib/biomarker-table/biomarker-table.component.stories.ts",722,967]};function webpackAsyncContext(req){if(!__webpack_require__.o(map,req))return Promise.resolve().then((()=>{var e=new Error("Cannot find module '"+req+"'");throw e.code="MODULE_NOT_FOUND",e}));var ids=map[req],id=ids[0];return Promise.all(ids.slice(1).map(__webpack_require__.e)).then((()=>__webpack_require__(id)))}webpackAsyncContext.keys=()=>Object.keys(map),webpackAsyncContext.id="./libs/components/organisms lazy recursive ^\\.\\/.*$ include: (?%21.*node_modules)(?:\\/libs\\/components\\/organisms(?:\\/(?%21\\.)(?:(?:(?%21(?:^%7C\\/)\\.).)*?)\\/%7C\\/%7C$)(?%21\\.)(?=.)[^/]*?\\.stories\\.(js%7Cjsx%7Cts%7Ctsx))$",module.exports=webpackAsyncContext},"./libs/components/organisms/.storybook/preview.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{argTypesEnhancers:()=>argTypesEnhancers,decorators:()=>decorators,parameters:()=>parameters});var angular=__webpack_require__("./node_modules/@storybook/addon-docs/angular/index.js");__webpack_require__("./node_modules/zone.js/fesm2015/zone.js");const documentation_namespaceObject=JSON.parse('{"pipes":[],"interfaces":[{"name":"DataCell","id":"interface-DataCell-2b9c6aa9516b4764c15a5fbfb4c7a6548ac2362bcf1a47f1f60691b9b4c439b5d4e09b80260556809daf9d6dcecaf532bbbde8ca8662c6ceaafbde28fcc99e25","file":"libs/components/organisms/src/lib/biomarker-table/biomarker-table.component.ts","deprecated":false,"deprecationMessage":"","type":"interface","sourceCode":"import { CdkVirtualScrollViewport, ScrollingModule } from \'@angular/cdk/scrolling\';\\nimport { CommonModule } from \'@angular/common\';\\nimport {\\n  ChangeDetectionStrategy,\\n  ChangeDetectorRef,\\n  Component,\\n  ElementRef,\\n  EventEmitter,\\n  HostListener,\\n  inject,\\n  Input,\\n  OnChanges,\\n  OnInit,\\n  Output,\\n  SimpleChanges,\\n  ViewChild,\\n} from \'@angular/core\';\\nimport { MatTableModule } from \'@angular/material/table\';\\nimport { HoverDirective } from \'@hra-ui/cdk\';\\nimport { GradientPoint, SizeLegend } from \'@hra-ui/components/atoms\';\\nimport {\\n  BiomarkerTableDataCardComponent,\\n  BiomarkerTableDataIconComponent,\\n  DataItem,\\n  SourceListItem,\\n} from \'@hra-ui/components/molecules\';\\nimport { TableVirtualScrollDataSource, TableVirtualScrollModule } from \'ng-table-virtual-scroll\';\\nimport { ReplaySubject } from \'rxjs\';\\n\\n/**\\n * RGBTriblet of type RGB to store color\\n */\\ntype RGBTriplet = [number, number, number];\\n\\n/**\\n * An interface representing a single cell of the table.\\n */\\nexport interface DataCell {\\n  /** Represents the color of the icon */\\n  color: string;\\n  /** Represents the size of the icon */\\n  size: number;\\n  /** Represents the data for the data card */\\n  data: {\\n    /** Cell name */\\n    cell: string;\\n    /** Biomarker name */\\n    biomarker: string;\\n    /** Mean expression value */\\n    meanExpression: number;\\n    /** Dataset count */\\n    dataset_count?: number;\\n  };\\n}\\n\\n/**\\n * Details of the Tissue\\n */\\nexport interface TissueInfo {\\n  /** ID of the Tissue */\\n  id: string;\\n  /** Name of the Tissue */\\n  label: string;\\n}\\n\\n/** Describes the composition of a single row in the table */\\nexport type DataRow<T> = [string, number | undefined, ...(T | undefined)[]];\\n\\n/** Cell types table, describing the types and quanitites of cells for a specific organ */\\n@Component({\\n  selector: \'hra-biomarker-table\',\\n  imports: [\\n    CommonModule,\\n    MatTableModule,\\n    BiomarkerTableDataIconComponent,\\n    HoverDirective,\\n    BiomarkerTableDataCardComponent,\\n    ScrollingModule,\\n    TableVirtualScrollModule,\\n  ],\\n  templateUrl: \'./biomarker-table.component.html\',\\n  styleUrls: [\'./biomarker-table.component.scss\'],\\n  changeDetection: ChangeDetectionStrategy.OnPush,\\n})\\nexport class BiomarkerTableComponent<T extends DataCell> implements OnInit, OnChanges {\\n  /**\\n   * Input: TissueInfo carrying the details of the tissue open\\n   */\\n  @Input() tissueInfo: TissueInfo = {\\n    id: \'\',\\n    label: \'\',\\n  };\\n\\n  /** Columns for the table */\\n  @Input() columns: string[] = [];\\n\\n  /** Source list for biomarker table */\\n  @Input() dataSources: SourceListItem[] = [];\\n\\n  /** Rows of the table */\\n  @Input() data: DataRow<T>[] = [];\\n\\n  /** Gradient colors along with their stop points */\\n  @Input() gradient: GradientPoint[] = [];\\n\\n  /** Taking input for the radius of the circle and the label to be displayed. */\\n  @Input() sizes: SizeLegend[] = [];\\n\\n  /** Cell id which is hovered, used for highlighting */\\n  @Input() highlightedCellId = \'\';\\n\\n  /** List of cell ids in the illustration */\\n  @Input() illustrationIds: string[] = [];\\n\\n  /** Emits cell type label when row is hovered */\\n  @Output() readonly rowHover = new EventEmitter<string>();\\n\\n  /** Reference to virtual scroll viewport */\\n  @ViewChild(CdkVirtualScrollViewport, { static: true }) vscroll!: CdkVirtualScrollViewport;\\n\\n  /** Reference to biomarker table */\\n  @ViewChild(\'table\', { static: true, read: ElementRef }) table!: ElementRef;\\n\\n  /** Columns replaysubject */\\n  readonly columns$ = new ReplaySubject<string[]>(1);\\n\\n  /** Cell width (px) */\\n  private readonly cellWidth = 44;\\n  /** Extra columns to render outside the visible viewport */\\n  private readonly extraDisplayedColumnCount = 2;\\n\\n  /** Current horizontal viewport size */\\n  private horizontalViewportSize = 400;\\n  /** Current horizontal scroll offset */\\n  private horizontalScrollOffset = 0;\\n  /** Current displayed column count */\\n  private displayedColumnCount = 10;\\n  /** Current displayed column offset */\\n  private displayedColumnOffset = 0;\\n\\n  /** Gets the current width of the prefiller column */\\n  get preFillerWidth(): string {\\n    return `${this.cellWidth * this.displayedColumnOffset}px`;\\n  }\\n\\n  /** Gets the current width of the postfiller column */\\n  get postFillerWidth(): string {\\n    const count = this.columns.length - this.displayedColumnCount - this.displayedColumnOffset;\\n    return `${this.cellWidth * count}px`;\\n  }\\n\\n  /** Source for the table */\\n  readonly dataSource = new TableVirtualScrollDataSource<DataRow<T>>([]);\\n\\n  /** Change detection */\\n  private readonly cdr = inject(ChangeDetectorRef);\\n\\n  /**\\n   * Subscribes to scroll event on virtual scroll viewport and checks displayed columns\\n   */\\n  ngOnInit(): void {\\n    const scroll$ = this.vscroll.scrollable.elementScrolled();\\n    scroll$.subscribe(() => this.checkDisplayedColumns());\\n  }\\n\\n  /**\\n   * Sets the data source for the table on every change\\n   * Sorts the biomarker table on illustrationIds change\\n   * @param changes object consisting of change in the Input\\n   */\\n  ngOnChanges(changes: SimpleChanges): void {\\n    this.checkDisplayedColumns(\'columns\' in changes);\\n    if (\'data\' in changes || \'illustrationIds\' in changes) {\\n      this.dataSource.data = this.sortTableData(this.data);\\n    }\\n  }\\n\\n  /**\\n   * Checks for column updates on mouse move\\n   */\\n  @HostListener(\'window:mousemove\', [\'$event\'])\\n  onMouseMove() {\\n    this.checkDisplayedColumns();\\n  }\\n\\n  /**\\n   * Returns index value\\n   */\\n  trackByIndex(index: number): number {\\n    return index;\\n  }\\n\\n  /**\\n   * Checks to see if columns should be updated\\n   */\\n  checkDisplayedColumns(forceUpdate = false): void {\\n    const scrollable = this.vscroll.scrollable;\\n    const size = scrollable.measureViewportSize(\'horizontal\');\\n    const offset = scrollable.measureScrollOffset(\'start\');\\n    let shouldUpdate = forceUpdate;\\n\\n    if (size !== this.horizontalViewportSize) {\\n      this.updateHorizontalViewportSize(size);\\n      shouldUpdate = true;\\n    }\\n    if (offset !== this.horizontalScrollOffset) {\\n      this.updateHorizontalViewportOffset(offset);\\n      shouldUpdate = true;\\n    }\\n\\n    if (shouldUpdate) {\\n      this.updateColumns();\\n    }\\n  }\\n\\n  /**\\n   * Updates horizontal viewport size and updates displayed column count\\n   */\\n  updateHorizontalViewportSize(size: number): void {\\n    this.horizontalViewportSize = size;\\n    this.displayedColumnCount =\\n      Math.ceil(this.horizontalViewportSize / this.cellWidth) + this.extraDisplayedColumnCount;\\n  }\\n\\n  /**\\n   * Updates horizontal viewport offset and updates displayed column offset\\n   */\\n  updateHorizontalViewportOffset(offset: number): void {\\n    this.horizontalScrollOffset = offset;\\n    this.displayedColumnOffset = Math.max(Math.floor(offset / this.cellWidth) - this.extraDisplayedColumnCount / 2, 0);\\n  }\\n\\n  /**\\n   * Updates table columns with prefiller and postfiller columns\\n   */\\n  updateColumns(): void {\\n    const { displayedColumnCount, displayedColumnOffset } = this;\\n    const columns = [\'type\', \'count\'];\\n    if (this.displayedColumnOffset > 0) {\\n      columns.push(\'preFiller\');\\n    }\\n\\n    const displayedColumns = this.columns.slice(displayedColumnOffset, displayedColumnOffset + displayedColumnCount);\\n    columns.push(...displayedColumns);\\n\\n    if (displayedColumnOffset + displayedColumnCount < this.columns.length) {\\n      columns.push(\'postFiller\');\\n    }\\n\\n    this.columns$.next(columns);\\n    this.cdr.detectChanges();\\n  }\\n\\n  /**\\n   * Sorts table by cell type alphabetically, then puts cells that are in the illustration on top\\n   */\\n  sortTableData(data: DataRow<T>[]): DataRow<T>[] {\\n    const illustrationIdsSet = new Set(this.illustrationIds);\\n    const inIllustration = new Map<DataRow<T>, boolean>();\\n    for (const row of data) {\\n      const id = this.getHoverId(row);\\n      inIllustration.set(row, illustrationIdsSet.has(id));\\n    }\\n\\n    return [...data].sort((row1, row2) => {\\n      const in1 = inIllustration.get(row1);\\n      const in2 = inIllustration.get(row2);\\n\\n      if (in1 && !in2) {\\n        return -1;\\n      } else if (!in1 && in2) {\\n        return 1;\\n      }\\n\\n      return row1[0].localeCompare(row2[0]);\\n    });\\n  }\\n\\n  /**\\n   * Returns true if id matches the cell id of the row\\n   * @param row Highlighted row\\n   */\\n  isHighlighted(row: DataRow<T>): boolean {\\n    return this.getHoverId(row) === this.highlightedCellId;\\n  }\\n\\n  /**\\n   * Gets hover id from row\\n   * @param data row data\\n   * @returns cell type id\\n   */\\n  getHoverId(data: DataRow<T>): string {\\n    const entry = data.slice(2).find((item) => item) as T;\\n    return entry?.data.cell;\\n  }\\n\\n  /** Lerp function to give value beween min and max value based on the given value\\n   *\\n   * @param value\\n   * @param min\\n   * @param max\\n   * @returns\\n   */\\n  lerp(value: number, min: number, max: number): number {\\n    return min * (1 - value) + max * value;\\n  }\\n\\n  /**\\n   * Converts HexCode to RGB\\n   * @param hex\\n   * @returns\\n   */\\n  hex2rgb(hex: string): RGBTriplet {\\n    const r = parseInt(hex.slice(1, 3), 16);\\n    const g = parseInt(hex.slice(3, 5), 16);\\n    const b = parseInt(hex.slice(5, 7), 16);\\n    return [r, g, b];\\n  }\\n\\n  /**\\n   * Gets Min and Max color grade based on the meanExpression value\\n   * @param meanExpression\\n   * @returns\\n   */\\n  getMinMaxColor(meanExpression: number): { minColor: RGBTriplet; maxColor: RGBTriplet } {\\n    const index = this.gradient.findIndex((item, i, arr) => {\\n      return meanExpression >= item.percentage && meanExpression <= arr[i + 1]?.percentage;\\n    });\\n\\n    const minColor: RGBTriplet = this.hex2rgb(this.gradient[index]?.color ?? this.gradient[0].color);\\n    const maxColor: RGBTriplet = this.hex2rgb(this.gradient[index + 1].color);\\n\\n    return { minColor, maxColor };\\n  }\\n\\n  /**\\n   * Gets Min and Max size grade based on the Percentage value\\n   * @param percentage\\n   * @returns\\n   */\\n  getMinMaxSize(percentage: number): { minSize: number; maxSize: number } {\\n    const index = this.sizes.findIndex((item, i, arr) => {\\n      return percentage >= parseFloat(item.label) / 100 && percentage <= parseFloat(arr[i + 1]?.label) / 100;\\n    });\\n    const minSize: number = this.sizes[index]?.radius;\\n    const maxSize: number = this.sizes[index + 1].radius;\\n    return { minSize, maxSize };\\n  }\\n\\n  /**\\n   * Calculates the color of this value on this gradient\\n   * @param value\\n   * @returns\\n   */\\n  getColor(value: number): string {\\n    const { minColor, maxColor } = this.getMinMaxColor(value * 100);\\n    return (\\n      \'#\' +\\n      minColor\\n        .map((min, index) => this.lerp(value, min, maxColor[index]))\\n        .map((component) => {\\n          const hex = Math.round(component).toString(16);\\n          return hex.length === 1 ? \'0\' + hex : hex;\\n        })\\n        .join(\'\')\\n    );\\n  }\\n\\n  /**\\n   * gets Size of the Cell based on the percentage value\\n   * @param value\\n   * @returns\\n   */\\n  getSize(value: number): number {\\n    const { minSize, maxSize } = this.getMinMaxSize(value);\\n    return this.lerp(value, minSize, maxSize);\\n  }\\n\\n  /**\\n   * Processes the object for hover data for Table Cell\\n   * @param index index of the row of the datasource\\n   * @param row row of the datasource\\n   * @returns\\n   */\\n  getHoverData([index, row]: [number, DataRow<T>]): DataItem[][] {\\n    if (row[index] === undefined) {\\n      return [];\\n    }\\n\\n    const {\\n      tissueInfo: { id, label },\\n    } = this;\\n    const {\\n      data: { cell, biomarker, meanExpression, dataset_count },\\n    } = row[index] as T;\\n\\n    return [\\n      [\\n        { label: \'Functional Tissue Unit Name\', value: label },\\n        { label: \'Uberon ID\', value: id },\\n        { label: \'#Datasets\', value: `${dataset_count ?? 0}` },\\n      ],\\n      [\\n        { label: \'Cell Type Name\', value: row[0] },\\n        { label: \'CL ID\', value: cell },\\n        { label: \'Number of Cells\', value: `${row[1]}` },\\n      ],\\n      [\\n        { label: \'Gene Name\', value: this.columns[index - 2] },\\n        { label: \'HGNC ID\', value: biomarker },\\n        { label: \'Mean Expression Value\', value: meanExpression.toFixed(6) },\\n      ],\\n    ];\\n  }\\n\\n  /**\\n   * Sets and emits cell type id on row hover\\n   * @param hoverId cell type id\\n   */\\n  setHoverId(hoverId?: string): void {\\n    this.highlightedCellId = hoverId ?? \'\';\\n    this.rowHover.emit(hoverId);\\n  }\\n}\\n","properties":[{"name":"color","deprecated":false,"deprecationMessage":"","type":"string","indexKey":"","optional":false,"description":"<p>Represents the color of the icon</p>\\n","line":40,"rawdescription":"\\nRepresents the color of the icon"},{"name":"data","deprecated":false,"deprecationMessage":"","type":"literal type","indexKey":"","optional":false,"description":"<p>Represents the data for the data card</p>\\n","line":44,"rawdescription":"\\nRepresents the data for the data card"},{"name":"size","deprecated":false,"deprecationMessage":"","type":"number","indexKey":"","optional":false,"description":"<p>Represents the size of the icon</p>\\n","line":42,"rawdescription":"\\nRepresents the size of the icon"}],"indexSignatures":[],"kind":171,"description":"<p>An interface representing a single cell of the table.</p>\\n","rawdescription":"\\n\\nAn interface representing a single cell of the table.\\n","methods":[],"extends":[]},{"name":"TissueInfo","id":"interface-TissueInfo-2b9c6aa9516b4764c15a5fbfb4c7a6548ac2362bcf1a47f1f60691b9b4c439b5d4e09b80260556809daf9d6dcecaf532bbbde8ca8662c6ceaafbde28fcc99e25","file":"libs/components/organisms/src/lib/biomarker-table/biomarker-table.component.ts","deprecated":false,"deprecationMessage":"","type":"interface","sourceCode":"import { CdkVirtualScrollViewport, ScrollingModule } from \'@angular/cdk/scrolling\';\\nimport { CommonModule } from \'@angular/common\';\\nimport {\\n  ChangeDetectionStrategy,\\n  ChangeDetectorRef,\\n  Component,\\n  ElementRef,\\n  EventEmitter,\\n  HostListener,\\n  inject,\\n  Input,\\n  OnChanges,\\n  OnInit,\\n  Output,\\n  SimpleChanges,\\n  ViewChild,\\n} from \'@angular/core\';\\nimport { MatTableModule } from \'@angular/material/table\';\\nimport { HoverDirective } from \'@hra-ui/cdk\';\\nimport { GradientPoint, SizeLegend } from \'@hra-ui/components/atoms\';\\nimport {\\n  BiomarkerTableDataCardComponent,\\n  BiomarkerTableDataIconComponent,\\n  DataItem,\\n  SourceListItem,\\n} from \'@hra-ui/components/molecules\';\\nimport { TableVirtualScrollDataSource, TableVirtualScrollModule } from \'ng-table-virtual-scroll\';\\nimport { ReplaySubject } from \'rxjs\';\\n\\n/**\\n * RGBTriblet of type RGB to store color\\n */\\ntype RGBTriplet = [number, number, number];\\n\\n/**\\n * An interface representing a single cell of the table.\\n */\\nexport interface DataCell {\\n  /** Represents the color of the icon */\\n  color: string;\\n  /** Represents the size of the icon */\\n  size: number;\\n  /** Represents the data for the data card */\\n  data: {\\n    /** Cell name */\\n    cell: string;\\n    /** Biomarker name */\\n    biomarker: string;\\n    /** Mean expression value */\\n    meanExpression: number;\\n    /** Dataset count */\\n    dataset_count?: number;\\n  };\\n}\\n\\n/**\\n * Details of the Tissue\\n */\\nexport interface TissueInfo {\\n  /** ID of the Tissue */\\n  id: string;\\n  /** Name of the Tissue */\\n  label: string;\\n}\\n\\n/** Describes the composition of a single row in the table */\\nexport type DataRow<T> = [string, number | undefined, ...(T | undefined)[]];\\n\\n/** Cell types table, describing the types and quanitites of cells for a specific organ */\\n@Component({\\n  selector: \'hra-biomarker-table\',\\n  imports: [\\n    CommonModule,\\n    MatTableModule,\\n    BiomarkerTableDataIconComponent,\\n    HoverDirective,\\n    BiomarkerTableDataCardComponent,\\n    ScrollingModule,\\n    TableVirtualScrollModule,\\n  ],\\n  templateUrl: \'./biomarker-table.component.html\',\\n  styleUrls: [\'./biomarker-table.component.scss\'],\\n  changeDetection: ChangeDetectionStrategy.OnPush,\\n})\\nexport class BiomarkerTableComponent<T extends DataCell> implements OnInit, OnChanges {\\n  /**\\n   * Input: TissueInfo carrying the details of the tissue open\\n   */\\n  @Input() tissueInfo: TissueInfo = {\\n    id: \'\',\\n    label: \'\',\\n  };\\n\\n  /** Columns for the table */\\n  @Input() columns: string[] = [];\\n\\n  /** Source list for biomarker table */\\n  @Input() dataSources: SourceListItem[] = [];\\n\\n  /** Rows of the table */\\n  @Input() data: DataRow<T>[] = [];\\n\\n  /** Gradient colors along with their stop points */\\n  @Input() gradient: GradientPoint[] = [];\\n\\n  /** Taking input for the radius of the circle and the label to be displayed. */\\n  @Input() sizes: SizeLegend[] = [];\\n\\n  /** Cell id which is hovered, used for highlighting */\\n  @Input() highlightedCellId = \'\';\\n\\n  /** List of cell ids in the illustration */\\n  @Input() illustrationIds: string[] = [];\\n\\n  /** Emits cell type label when row is hovered */\\n  @Output() readonly rowHover = new EventEmitter<string>();\\n\\n  /** Reference to virtual scroll viewport */\\n  @ViewChild(CdkVirtualScrollViewport, { static: true }) vscroll!: CdkVirtualScrollViewport;\\n\\n  /** Reference to biomarker table */\\n  @ViewChild(\'table\', { static: true, read: ElementRef }) table!: ElementRef;\\n\\n  /** Columns replaysubject */\\n  readonly columns$ = new ReplaySubject<string[]>(1);\\n\\n  /** Cell width (px) */\\n  private readonly cellWidth = 44;\\n  /** Extra columns to render outside the visible viewport */\\n  private readonly extraDisplayedColumnCount = 2;\\n\\n  /** Current horizontal viewport size */\\n  private horizontalViewportSize = 400;\\n  /** Current horizontal scroll offset */\\n  private horizontalScrollOffset = 0;\\n  /** Current displayed column count */\\n  private displayedColumnCount = 10;\\n  /** Current displayed column offset */\\n  private displayedColumnOffset = 0;\\n\\n  /** Gets the current width of the prefiller column */\\n  get preFillerWidth(): string {\\n    return `${this.cellWidth * this.displayedColumnOffset}px`;\\n  }\\n\\n  /** Gets the current width of the postfiller column */\\n  get postFillerWidth(): string {\\n    const count = this.columns.length - this.displayedColumnCount - this.displayedColumnOffset;\\n    return `${this.cellWidth * count}px`;\\n  }\\n\\n  /** Source for the table */\\n  readonly dataSource = new TableVirtualScrollDataSource<DataRow<T>>([]);\\n\\n  /** Change detection */\\n  private readonly cdr = inject(ChangeDetectorRef);\\n\\n  /**\\n   * Subscribes to scroll event on virtual scroll viewport and checks displayed columns\\n   */\\n  ngOnInit(): void {\\n    const scroll$ = this.vscroll.scrollable.elementScrolled();\\n    scroll$.subscribe(() => this.checkDisplayedColumns());\\n  }\\n\\n  /**\\n   * Sets the data source for the table on every change\\n   * Sorts the biomarker table on illustrationIds change\\n   * @param changes object consisting of change in the Input\\n   */\\n  ngOnChanges(changes: SimpleChanges): void {\\n    this.checkDisplayedColumns(\'columns\' in changes);\\n    if (\'data\' in changes || \'illustrationIds\' in changes) {\\n      this.dataSource.data = this.sortTableData(this.data);\\n    }\\n  }\\n\\n  /**\\n   * Checks for column updates on mouse move\\n   */\\n  @HostListener(\'window:mousemove\', [\'$event\'])\\n  onMouseMove() {\\n    this.checkDisplayedColumns();\\n  }\\n\\n  /**\\n   * Returns index value\\n   */\\n  trackByIndex(index: number): number {\\n    return index;\\n  }\\n\\n  /**\\n   * Checks to see if columns should be updated\\n   */\\n  checkDisplayedColumns(forceUpdate = false): void {\\n    const scrollable = this.vscroll.scrollable;\\n    const size = scrollable.measureViewportSize(\'horizontal\');\\n    const offset = scrollable.measureScrollOffset(\'start\');\\n    let shouldUpdate = forceUpdate;\\n\\n    if (size !== this.horizontalViewportSize) {\\n      this.updateHorizontalViewportSize(size);\\n      shouldUpdate = true;\\n    }\\n    if (offset !== this.horizontalScrollOffset) {\\n      this.updateHorizontalViewportOffset(offset);\\n      shouldUpdate = true;\\n    }\\n\\n    if (shouldUpdate) {\\n      this.updateColumns();\\n    }\\n  }\\n\\n  /**\\n   * Updates horizontal viewport size and updates displayed column count\\n   */\\n  updateHorizontalViewportSize(size: number): void {\\n    this.horizontalViewportSize = size;\\n    this.displayedColumnCount =\\n      Math.ceil(this.horizontalViewportSize / this.cellWidth) + this.extraDisplayedColumnCount;\\n  }\\n\\n  /**\\n   * Updates horizontal viewport offset and updates displayed column offset\\n   */\\n  updateHorizontalViewportOffset(offset: number): void {\\n    this.horizontalScrollOffset = offset;\\n    this.displayedColumnOffset = Math.max(Math.floor(offset / this.cellWidth) - this.extraDisplayedColumnCount / 2, 0);\\n  }\\n\\n  /**\\n   * Updates table columns with prefiller and postfiller columns\\n   */\\n  updateColumns(): void {\\n    const { displayedColumnCount, displayedColumnOffset } = this;\\n    const columns = [\'type\', \'count\'];\\n    if (this.displayedColumnOffset > 0) {\\n      columns.push(\'preFiller\');\\n    }\\n\\n    const displayedColumns = this.columns.slice(displayedColumnOffset, displayedColumnOffset + displayedColumnCount);\\n    columns.push(...displayedColumns);\\n\\n    if (displayedColumnOffset + displayedColumnCount < this.columns.length) {\\n      columns.push(\'postFiller\');\\n    }\\n\\n    this.columns$.next(columns);\\n    this.cdr.detectChanges();\\n  }\\n\\n  /**\\n   * Sorts table by cell type alphabetically, then puts cells that are in the illustration on top\\n   */\\n  sortTableData(data: DataRow<T>[]): DataRow<T>[] {\\n    const illustrationIdsSet = new Set(this.illustrationIds);\\n    const inIllustration = new Map<DataRow<T>, boolean>();\\n    for (const row of data) {\\n      const id = this.getHoverId(row);\\n      inIllustration.set(row, illustrationIdsSet.has(id));\\n    }\\n\\n    return [...data].sort((row1, row2) => {\\n      const in1 = inIllustration.get(row1);\\n      const in2 = inIllustration.get(row2);\\n\\n      if (in1 && !in2) {\\n        return -1;\\n      } else if (!in1 && in2) {\\n        return 1;\\n      }\\n\\n      return row1[0].localeCompare(row2[0]);\\n    });\\n  }\\n\\n  /**\\n   * Returns true if id matches the cell id of the row\\n   * @param row Highlighted row\\n   */\\n  isHighlighted(row: DataRow<T>): boolean {\\n    return this.getHoverId(row) === this.highlightedCellId;\\n  }\\n\\n  /**\\n   * Gets hover id from row\\n   * @param data row data\\n   * @returns cell type id\\n   */\\n  getHoverId(data: DataRow<T>): string {\\n    const entry = data.slice(2).find((item) => item) as T;\\n    return entry?.data.cell;\\n  }\\n\\n  /** Lerp function to give value beween min and max value based on the given value\\n   *\\n   * @param value\\n   * @param min\\n   * @param max\\n   * @returns\\n   */\\n  lerp(value: number, min: number, max: number): number {\\n    return min * (1 - value) + max * value;\\n  }\\n\\n  /**\\n   * Converts HexCode to RGB\\n   * @param hex\\n   * @returns\\n   */\\n  hex2rgb(hex: string): RGBTriplet {\\n    const r = parseInt(hex.slice(1, 3), 16);\\n    const g = parseInt(hex.slice(3, 5), 16);\\n    const b = parseInt(hex.slice(5, 7), 16);\\n    return [r, g, b];\\n  }\\n\\n  /**\\n   * Gets Min and Max color grade based on the meanExpression value\\n   * @param meanExpression\\n   * @returns\\n   */\\n  getMinMaxColor(meanExpression: number): { minColor: RGBTriplet; maxColor: RGBTriplet } {\\n    const index = this.gradient.findIndex((item, i, arr) => {\\n      return meanExpression >= item.percentage && meanExpression <= arr[i + 1]?.percentage;\\n    });\\n\\n    const minColor: RGBTriplet = this.hex2rgb(this.gradient[index]?.color ?? this.gradient[0].color);\\n    const maxColor: RGBTriplet = this.hex2rgb(this.gradient[index + 1].color);\\n\\n    return { minColor, maxColor };\\n  }\\n\\n  /**\\n   * Gets Min and Max size grade based on the Percentage value\\n   * @param percentage\\n   * @returns\\n   */\\n  getMinMaxSize(percentage: number): { minSize: number; maxSize: number } {\\n    const index = this.sizes.findIndex((item, i, arr) => {\\n      return percentage >= parseFloat(item.label) / 100 && percentage <= parseFloat(arr[i + 1]?.label) / 100;\\n    });\\n    const minSize: number = this.sizes[index]?.radius;\\n    const maxSize: number = this.sizes[index + 1].radius;\\n    return { minSize, maxSize };\\n  }\\n\\n  /**\\n   * Calculates the color of this value on this gradient\\n   * @param value\\n   * @returns\\n   */\\n  getColor(value: number): string {\\n    const { minColor, maxColor } = this.getMinMaxColor(value * 100);\\n    return (\\n      \'#\' +\\n      minColor\\n        .map((min, index) => this.lerp(value, min, maxColor[index]))\\n        .map((component) => {\\n          const hex = Math.round(component).toString(16);\\n          return hex.length === 1 ? \'0\' + hex : hex;\\n        })\\n        .join(\'\')\\n    );\\n  }\\n\\n  /**\\n   * gets Size of the Cell based on the percentage value\\n   * @param value\\n   * @returns\\n   */\\n  getSize(value: number): number {\\n    const { minSize, maxSize } = this.getMinMaxSize(value);\\n    return this.lerp(value, minSize, maxSize);\\n  }\\n\\n  /**\\n   * Processes the object for hover data for Table Cell\\n   * @param index index of the row of the datasource\\n   * @param row row of the datasource\\n   * @returns\\n   */\\n  getHoverData([index, row]: [number, DataRow<T>]): DataItem[][] {\\n    if (row[index] === undefined) {\\n      return [];\\n    }\\n\\n    const {\\n      tissueInfo: { id, label },\\n    } = this;\\n    const {\\n      data: { cell, biomarker, meanExpression, dataset_count },\\n    } = row[index] as T;\\n\\n    return [\\n      [\\n        { label: \'Functional Tissue Unit Name\', value: label },\\n        { label: \'Uberon ID\', value: id },\\n        { label: \'#Datasets\', value: `${dataset_count ?? 0}` },\\n      ],\\n      [\\n        { label: \'Cell Type Name\', value: row[0] },\\n        { label: \'CL ID\', value: cell },\\n        { label: \'Number of Cells\', value: `${row[1]}` },\\n      ],\\n      [\\n        { label: \'Gene Name\', value: this.columns[index - 2] },\\n        { label: \'HGNC ID\', value: biomarker },\\n        { label: \'Mean Expression Value\', value: meanExpression.toFixed(6) },\\n      ],\\n    ];\\n  }\\n\\n  /**\\n   * Sets and emits cell type id on row hover\\n   * @param hoverId cell type id\\n   */\\n  setHoverId(hoverId?: string): void {\\n    this.highlightedCellId = hoverId ?? \'\';\\n    this.rowHover.emit(hoverId);\\n  }\\n}\\n","properties":[{"name":"id","deprecated":false,"deprecationMessage":"","type":"string","indexKey":"","optional":false,"description":"<p>ID of the Tissue</p>\\n","line":61,"rawdescription":"\\nID of the Tissue"},{"name":"label","deprecated":false,"deprecationMessage":"","type":"string","indexKey":"","optional":false,"description":"<p>Name of the Tissue</p>\\n","line":63,"rawdescription":"\\nName of the Tissue"}],"indexSignatures":[],"kind":171,"description":"<p>Details of the Tissue</p>\\n","rawdescription":"\\n\\nDetails of the Tissue\\n","methods":[],"extends":[]}],"injectables":[],"guards":[],"interceptors":[],"classes":[],"directives":[],"components":[{"name":"BiomarkerTableComponent","id":"component-BiomarkerTableComponent-2b9c6aa9516b4764c15a5fbfb4c7a6548ac2362bcf1a47f1f60691b9b4c439b5d4e09b80260556809daf9d6dcecaf532bbbde8ca8662c6ceaafbde28fcc99e25","file":"libs/components/organisms/src/lib/biomarker-table/biomarker-table.component.ts","changeDetection":"ChangeDetectionStrategy.OnPush","encapsulation":[],"entryComponents":[],"inputs":[],"outputs":[],"providers":[],"selector":"hra-biomarker-table","styleUrls":["./biomarker-table.component.scss"],"styles":[],"templateUrl":["./biomarker-table.component.html"],"viewProviders":[],"hostDirectives":[],"inputsClass":[{"name":"columns","defaultValue":"[]","deprecated":false,"deprecationMessage":"","rawdescription":"\\nColumns for the table","description":"<p>Columns for the table</p>\\n","line":95,"type":"string[]","decorators":[]},{"name":"data","defaultValue":"[]","deprecated":false,"deprecationMessage":"","rawdescription":"\\nRows of the table","description":"<p>Rows of the table</p>\\n","line":101,"type":"DataRow<T>[]","decorators":[]},{"name":"dataSources","defaultValue":"[]","deprecated":false,"deprecationMessage":"","rawdescription":"\\nSource list for biomarker table","description":"<p>Source list for biomarker table</p>\\n","line":98,"type":"SourceListItem[]","decorators":[]},{"name":"gradient","defaultValue":"[]","deprecated":false,"deprecationMessage":"","rawdescription":"\\nGradient colors along with their stop points","description":"<p>Gradient colors along with their stop points</p>\\n","line":104,"type":"GradientPoint[]","decorators":[]},{"name":"highlightedCellId","defaultValue":"\'\'","deprecated":false,"deprecationMessage":"","rawdescription":"\\nCell id which is hovered, used for highlighting","description":"<p>Cell id which is hovered, used for highlighting</p>\\n","line":110,"type":"string","decorators":[]},{"name":"illustrationIds","defaultValue":"[]","deprecated":false,"deprecationMessage":"","rawdescription":"\\nList of cell ids in the illustration","description":"<p>List of cell ids in the illustration</p>\\n","line":113,"type":"string[]","decorators":[]},{"name":"sizes","defaultValue":"[]","deprecated":false,"deprecationMessage":"","rawdescription":"\\nTaking input for the radius of the circle and the label to be displayed.","description":"<p>Taking input for the radius of the circle and the label to be displayed.</p>\\n","line":107,"type":"SizeLegend[]","decorators":[]},{"name":"tissueInfo","defaultValue":"{\\n    id: \'\',\\n    label: \'\',\\n  }","deprecated":false,"deprecationMessage":"","rawdescription":"\\n\\nInput: TissueInfo carrying the details of the tissue open\\n","description":"<p>Input: TissueInfo carrying the details of the tissue open</p>\\n","line":89,"type":"TissueInfo","decorators":[]}],"outputsClass":[{"name":"rowHover","defaultValue":"new EventEmitter<string>()","deprecated":false,"deprecationMessage":"","rawdescription":"\\nEmits cell type label when row is hovered","description":"<p>Emits cell type label when row is hovered</p>\\n","line":116,"type":"EventEmitter"}],"propertiesClass":[{"name":"cdr","defaultValue":"inject(ChangeDetectorRef)","deprecated":false,"deprecationMessage":"","type":"","indexKey":"","optional":false,"description":"<p>Change detection</p>\\n","line":156,"rawdescription":"\\nChange detection","modifierKind":[123,148]},{"name":"cellWidth","defaultValue":"44","deprecated":false,"deprecationMessage":"","type":"number","indexKey":"","optional":false,"description":"<p>Cell width (px)</p>\\n","line":128,"rawdescription":"\\nCell width (px)","modifierKind":[123,148]},{"name":"columns$","defaultValue":"new ReplaySubject<string[]>(1)","deprecated":false,"deprecationMessage":"","type":"","indexKey":"","optional":false,"description":"<p>Columns replaysubject</p>\\n","line":125,"rawdescription":"\\nColumns replaysubject","modifierKind":[148]},{"name":"dataSource","defaultValue":"new TableVirtualScrollDataSource<DataRow<T>>([])","deprecated":false,"deprecationMessage":"","type":"","indexKey":"","optional":false,"description":"<p>Source for the table</p>\\n","line":153,"rawdescription":"\\nSource for the table","modifierKind":[148]},{"name":"displayedColumnCount","defaultValue":"10","deprecated":false,"deprecationMessage":"","type":"number","indexKey":"","optional":false,"description":"<p>Current displayed column count</p>\\n","line":137,"rawdescription":"\\nCurrent displayed column count","modifierKind":[123]},{"name":"displayedColumnOffset","defaultValue":"0","deprecated":false,"deprecationMessage":"","type":"number","indexKey":"","optional":false,"description":"<p>Current displayed column offset</p>\\n","line":139,"rawdescription":"\\nCurrent displayed column offset","modifierKind":[123]},{"name":"extraDisplayedColumnCount","defaultValue":"2","deprecated":false,"deprecationMessage":"","type":"number","indexKey":"","optional":false,"description":"<p>Extra columns to render outside the visible viewport</p>\\n","line":130,"rawdescription":"\\nExtra columns to render outside the visible viewport","modifierKind":[123,148]},{"name":"horizontalScrollOffset","defaultValue":"0","deprecated":false,"deprecationMessage":"","type":"number","indexKey":"","optional":false,"description":"<p>Current horizontal scroll offset</p>\\n","line":135,"rawdescription":"\\nCurrent horizontal scroll offset","modifierKind":[123]},{"name":"horizontalViewportSize","defaultValue":"400","deprecated":false,"deprecationMessage":"","type":"number","indexKey":"","optional":false,"description":"<p>Current horizontal viewport size</p>\\n","line":133,"rawdescription":"\\nCurrent horizontal viewport size","modifierKind":[123]},{"name":"table","deprecated":false,"deprecationMessage":"","type":"ElementRef","indexKey":"","optional":false,"description":"<p>Reference to biomarker table</p>\\n","line":122,"rawdescription":"\\nReference to biomarker table","decorators":[{"name":"ViewChild","stringifiedArguments":"\'table\', {static: true, read: ElementRef}"}],"modifierKind":[170]},{"name":"vscroll","deprecated":false,"deprecationMessage":"","type":"CdkVirtualScrollViewport","indexKey":"","optional":false,"description":"<p>Reference to virtual scroll viewport</p>\\n","line":119,"rawdescription":"\\nReference to virtual scroll viewport","decorators":[{"name":"ViewChild","stringifiedArguments":"CdkVirtualScrollViewport, {static: true}"}],"modifierKind":[170]}],"methodsClass":[{"name":"checkDisplayedColumns","args":[{"name":"forceUpdate","type":"","deprecated":false,"deprecationMessage":"","defaultValue":"false"}],"optional":false,"returnType":"void","typeParameters":[],"line":196,"deprecated":false,"deprecationMessage":"","rawdescription":"\\n\\nChecks to see if columns should be updated\\n","description":"<p>Checks to see if columns should be updated</p>\\n","jsdoctags":[{"name":"forceUpdate","type":"","deprecated":false,"deprecationMessage":"","defaultValue":"false","tagName":{"text":"param"}}]},{"name":"getColor","args":[{"name":"value","type":"number","deprecated":false,"deprecationMessage":""}],"optional":false,"returnType":"string","typeParameters":[],"line":355,"deprecated":false,"deprecationMessage":"","rawdescription":"\\n\\nCalculates the color of this value on this gradient\\n","description":"<p>Calculates the color of this value on this gradient</p>\\n","jsdoctags":[{"name":{"pos":10250,"end":10255,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"value"},"type":"number","deprecated":false,"deprecationMessage":"","tagName":{"pos":10244,"end":10249,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"param"},"comment":""},{"tagName":{"pos":10262,"end":10269,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"returns"},"comment":""}]},{"name":"getHoverData","args":[{"type":"[number, DataRow<T>]","deprecated":false,"deprecationMessage":""}],"optional":false,"returnType":"[][]","typeParameters":[],"line":385,"deprecated":false,"deprecationMessage":"","rawdescription":"\\n\\nProcesses the object for hover data for Table Cell\\n","description":"<p>Processes the object for hover data for Table Cell</p>\\n","jsdoctags":[{"type":"[number, DataRow<T>]","deprecated":false,"deprecationMessage":"","tagName":{"text":"param"}},{"tagName":{"pos":11079,"end":11086,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"returns"},"comment":""}]},{"name":"getHoverId","args":[{"name":"data","type":"DataRow<T>","deprecated":false,"deprecationMessage":""}],"optional":false,"returnType":"string","typeParameters":[],"line":292,"deprecated":false,"deprecationMessage":"","rawdescription":"\\n\\nGets hover id from row\\n","description":"<p>Gets hover id from row</p>\\n","jsdoctags":[{"name":{"pos":8345,"end":8349,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"data"},"type":"DataRow<T>","deprecated":false,"deprecationMessage":"","tagName":{"pos":8339,"end":8344,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"param"},"comment":"<p>row data</p>\\n"},{"tagName":{"pos":8365,"end":8372,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"returns"},"comment":"<p>cell type id</p>\\n"}]},{"name":"getMinMaxColor","args":[{"name":"meanExpression","type":"number","deprecated":false,"deprecationMessage":""}],"optional":false,"returnType":"literal type","typeParameters":[],"line":325,"deprecated":false,"deprecationMessage":"","rawdescription":"\\n\\nGets Min and Max color grade based on the meanExpression value\\n","description":"<p>Gets Min and Max color grade based on the meanExpression value</p>\\n","jsdoctags":[{"name":{"pos":9148,"end":9162,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"meanExpression"},"type":"number","deprecated":false,"deprecationMessage":"","tagName":{"pos":9142,"end":9147,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"param"},"comment":""},{"tagName":{"pos":9169,"end":9176,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"returns"},"comment":""}]},{"name":"getMinMaxSize","args":[{"name":"percentage","type":"number","deprecated":false,"deprecationMessage":""}],"optional":false,"returnType":"literal type","typeParameters":[],"line":341,"deprecated":false,"deprecationMessage":"","rawdescription":"\\n\\nGets Min and Max size grade based on the Percentage value\\n","description":"<p>Gets Min and Max size grade based on the Percentage value</p>\\n","jsdoctags":[{"name":{"pos":9740,"end":9750,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"percentage"},"type":"number","deprecated":false,"deprecationMessage":"","tagName":{"pos":9734,"end":9739,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"param"},"comment":""},{"tagName":{"pos":9757,"end":9764,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"returns"},"comment":""}]},{"name":"getSize","args":[{"name":"value","type":"number","deprecated":false,"deprecationMessage":""}],"optional":false,"returnType":"number","typeParameters":[],"line":374,"deprecated":false,"deprecationMessage":"","rawdescription":"\\n\\ngets Size of the Cell based on the percentage value\\n","description":"<p>gets Size of the Cell based on the percentage value</p>\\n","jsdoctags":[{"name":{"pos":10747,"end":10752,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"value"},"type":"number","deprecated":false,"deprecationMessage":"","tagName":{"pos":10741,"end":10746,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"param"},"comment":""},{"tagName":{"pos":10759,"end":10766,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"returns"},"comment":""}]},{"name":"hex2rgb","args":[{"name":"hex","type":"string","deprecated":false,"deprecationMessage":""}],"optional":false,"returnType":"RGBTriplet","typeParameters":[],"line":313,"deprecated":false,"deprecationMessage":"","rawdescription":"\\n\\nConverts HexCode to RGB\\n","description":"<p>Converts HexCode to RGB</p>\\n","jsdoctags":[{"name":{"pos":8839,"end":8842,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"hex"},"type":"string","deprecated":false,"deprecationMessage":"","tagName":{"pos":8833,"end":8838,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"param"},"comment":""},{"tagName":{"pos":8849,"end":8856,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"returns"},"comment":""}]},{"name":"isHighlighted","args":[{"name":"row","type":"DataRow<T>","deprecated":false,"deprecationMessage":""}],"optional":false,"returnType":"boolean","typeParameters":[],"line":283,"deprecated":false,"deprecationMessage":"","rawdescription":"\\n\\nReturns true if id matches the cell id of the row\\n","description":"<p>Returns true if id matches the cell id of the row</p>\\n","jsdoctags":[{"name":{"pos":8164,"end":8167,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"row"},"type":"DataRow<T>","deprecated":false,"deprecationMessage":"","tagName":{"pos":8158,"end":8163,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"param"},"comment":"<p>Highlighted row</p>\\n"}]},{"name":"lerp","args":[{"name":"value","type":"number","deprecated":false,"deprecationMessage":""},{"name":"min","type":"number","deprecated":false,"deprecationMessage":""},{"name":"max","type":"number","deprecated":false,"deprecationMessage":""}],"optional":false,"returnType":"number","typeParameters":[],"line":304,"deprecated":false,"deprecationMessage":"","rawdescription":"\\nLerp function to give value beween min and max value based on the given value\\n\\n","description":"<p>Lerp function to give value beween min and max value based on the given value</p>\\n","jsdoctags":[{"name":{"pos":8627,"end":8632,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"value"},"type":"number","deprecated":false,"deprecationMessage":"","tagName":{"pos":8621,"end":8626,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"param"},"comment":""},{"name":{"pos":8645,"end":8648,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"min"},"type":"number","deprecated":false,"deprecationMessage":"","tagName":{"pos":8639,"end":8644,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"param"},"comment":""},{"name":{"pos":8661,"end":8664,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"max"},"type":"number","deprecated":false,"deprecationMessage":"","tagName":{"pos":8655,"end":8660,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"param"},"comment":""},{"tagName":{"pos":8671,"end":8678,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"returns"},"comment":""}]},{"name":"ngOnChanges","args":[{"name":"changes","type":"SimpleChanges","deprecated":false,"deprecationMessage":""}],"optional":false,"returnType":"void","typeParameters":[],"line":171,"deprecated":false,"deprecationMessage":"","rawdescription":"\\n\\nSets the data source for the table on every change\\nSorts the biomarker table on illustrationIds change\\n","description":"<p>Sets the data source for the table on every change\\nSorts the biomarker table on illustrationIds change</p>\\n","jsdoctags":[{"name":{"pos":4925,"end":4932,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"changes"},"type":"SimpleChanges","deprecated":false,"deprecationMessage":"","tagName":{"pos":4919,"end":4924,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"param"},"comment":"<p>object consisting of change in the Input</p>\\n"}]},{"name":"ngOnInit","args":[],"optional":false,"returnType":"void","typeParameters":[],"line":161,"deprecated":false,"deprecationMessage":"","rawdescription":"\\n\\nSubscribes to scroll event on virtual scroll viewport and checks displayed columns\\n","description":"<p>Subscribes to scroll event on virtual scroll viewport and checks displayed columns</p>\\n"},{"name":"onMouseMove","args":[],"optional":false,"returnType":"void","typeParameters":[],"line":182,"deprecated":false,"deprecationMessage":"","rawdescription":"\\n\\nChecks for column updates on mouse move\\n","description":"<p>Checks for column updates on mouse move</p>\\n","decorators":[{"name":"HostListener","stringifiedArguments":"\'window:mousemove\', [\'$event\']"}],"modifierKind":[170]},{"name":"setHoverId","args":[{"name":"hoverId","type":"string","deprecated":false,"deprecationMessage":"","optional":true}],"optional":false,"returnType":"void","typeParameters":[],"line":420,"deprecated":false,"deprecationMessage":"","rawdescription":"\\n\\nSets and emits cell type id on row hover\\n","description":"<p>Sets and emits cell type id on row hover</p>\\n","jsdoctags":[{"name":{"pos":12033,"end":12040,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"hoverId"},"type":"string","deprecated":false,"deprecationMessage":"","optional":true,"tagName":{"pos":12027,"end":12032,"kind":80,"id":0,"flags":16842752,"transformFlags":0,"escapedText":"param"},"comment":"<p>cell type id</p>\\n"}]},{"name":"sortTableData","args":[{"name":"data","type":"DataRow<T>[]","deprecated":false,"deprecationMessage":""}],"optional":false,"returnType":"DataRow[]","typeParameters":[],"line":257,"deprecated":false,"deprecationMessage":"","rawdescription":"\\n\\nSorts table by cell type alphabetically, then puts cells that are in the illustration on top\\n","description":"<p>Sorts table by cell type alphabetically, then puts cells that are in the illustration on top</p>\\n","jsdoctags":[{"name":"data","type":"DataRow<T>[]","deprecated":false,"deprecationMessage":"","tagName":{"text":"param"}}]},{"name":"trackByIndex","args":[{"name":"index","type":"number","deprecated":false,"deprecationMessage":""}],"optional":false,"returnType":"number","typeParameters":[],"line":189,"deprecated":false,"deprecationMessage":"","rawdescription":"\\n\\nReturns index value\\n","description":"<p>Returns index value</p>\\n","jsdoctags":[{"name":"index","type":"number","deprecated":false,"deprecationMessage":"","tagName":{"text":"param"}}]},{"name":"updateColumns","args":[],"optional":false,"returnType":"void","typeParameters":[],"line":236,"deprecated":false,"deprecationMessage":"","rawdescription":"\\n\\nUpdates table columns with prefiller and postfiller columns\\n","description":"<p>Updates table columns with prefiller and postfiller columns</p>\\n"},{"name":"updateHorizontalViewportOffset","args":[{"name":"offset","type":"number","deprecated":false,"deprecationMessage":""}],"optional":false,"returnType":"void","typeParameters":[],"line":228,"deprecated":false,"deprecationMessage":"","rawdescription":"\\n\\nUpdates horizontal viewport offset and updates displayed column offset\\n","description":"<p>Updates horizontal viewport offset and updates displayed column offset</p>\\n","jsdoctags":[{"name":"offset","type":"number","deprecated":false,"deprecationMessage":"","tagName":{"text":"param"}}]},{"name":"updateHorizontalViewportSize","args":[{"name":"size","type":"number","deprecated":false,"deprecationMessage":""}],"optional":false,"returnType":"void","typeParameters":[],"line":219,"deprecated":false,"deprecationMessage":"","rawdescription":"\\n\\nUpdates horizontal viewport size and updates displayed column count\\n","description":"<p>Updates horizontal viewport size and updates displayed column count</p>\\n","jsdoctags":[{"name":"size","type":"number","deprecated":false,"deprecationMessage":"","tagName":{"text":"param"}}]}],"deprecated":false,"deprecationMessage":"","hostBindings":[],"hostListeners":[{"name":"window:mousemove","args":[],"argsDecorator":["$event"],"deprecated":false,"deprecationMessage":"","rawdescription":"\\n\\nChecks for column updates on mouse move\\n","description":"<p>Checks for column updates on mouse move</p>\\n","line":182}],"standalone":false,"imports":[{"name":"CommonModule","type":"module"},{"name":"MatTableModule","type":"module"},{"name":"BiomarkerTableDataIconComponent","type":"component"},{"name":"HoverDirective","type":"directive"},{"name":"BiomarkerTableDataCardComponent","type":"component"},{"name":"ScrollingModule","type":"module"},{"name":"TableVirtualScrollModule","type":"module"}],"description":"<p>Cell types table, describing the types and quanitites of cells for a specific organ</p>\\n","rawdescription":"\\nCell types table, describing the types and quanitites of cells for a specific organ","type":"component","sourceCode":"import { CdkVirtualScrollViewport, ScrollingModule } from \'@angular/cdk/scrolling\';\\nimport { CommonModule } from \'@angular/common\';\\nimport {\\n  ChangeDetectionStrategy,\\n  ChangeDetectorRef,\\n  Component,\\n  ElementRef,\\n  EventEmitter,\\n  HostListener,\\n  inject,\\n  Input,\\n  OnChanges,\\n  OnInit,\\n  Output,\\n  SimpleChanges,\\n  ViewChild,\\n} from \'@angular/core\';\\nimport { MatTableModule } from \'@angular/material/table\';\\nimport { HoverDirective } from \'@hra-ui/cdk\';\\nimport { GradientPoint, SizeLegend } from \'@hra-ui/components/atoms\';\\nimport {\\n  BiomarkerTableDataCardComponent,\\n  BiomarkerTableDataIconComponent,\\n  DataItem,\\n  SourceListItem,\\n} from \'@hra-ui/components/molecules\';\\nimport { TableVirtualScrollDataSource, TableVirtualScrollModule } from \'ng-table-virtual-scroll\';\\nimport { ReplaySubject } from \'rxjs\';\\n\\n/**\\n * RGBTriblet of type RGB to store color\\n */\\ntype RGBTriplet = [number, number, number];\\n\\n/**\\n * An interface representing a single cell of the table.\\n */\\nexport interface DataCell {\\n  /** Represents the color of the icon */\\n  color: string;\\n  /** Represents the size of the icon */\\n  size: number;\\n  /** Represents the data for the data card */\\n  data: {\\n    /** Cell name */\\n    cell: string;\\n    /** Biomarker name */\\n    biomarker: string;\\n    /** Mean expression value */\\n    meanExpression: number;\\n    /** Dataset count */\\n    dataset_count?: number;\\n  };\\n}\\n\\n/**\\n * Details of the Tissue\\n */\\nexport interface TissueInfo {\\n  /** ID of the Tissue */\\n  id: string;\\n  /** Name of the Tissue */\\n  label: string;\\n}\\n\\n/** Describes the composition of a single row in the table */\\nexport type DataRow<T> = [string, number | undefined, ...(T | undefined)[]];\\n\\n/** Cell types table, describing the types and quanitites of cells for a specific organ */\\n@Component({\\n  selector: \'hra-biomarker-table\',\\n  imports: [\\n    CommonModule,\\n    MatTableModule,\\n    BiomarkerTableDataIconComponent,\\n    HoverDirective,\\n    BiomarkerTableDataCardComponent,\\n    ScrollingModule,\\n    TableVirtualScrollModule,\\n  ],\\n  templateUrl: \'./biomarker-table.component.html\',\\n  styleUrls: [\'./biomarker-table.component.scss\'],\\n  changeDetection: ChangeDetectionStrategy.OnPush,\\n})\\nexport class BiomarkerTableComponent<T extends DataCell> implements OnInit, OnChanges {\\n  /**\\n   * Input: TissueInfo carrying the details of the tissue open\\n   */\\n  @Input() tissueInfo: TissueInfo = {\\n    id: \'\',\\n    label: \'\',\\n  };\\n\\n  /** Columns for the table */\\n  @Input() columns: string[] = [];\\n\\n  /** Source list for biomarker table */\\n  @Input() dataSources: SourceListItem[] = [];\\n\\n  /** Rows of the table */\\n  @Input() data: DataRow<T>[] = [];\\n\\n  /** Gradient colors along with their stop points */\\n  @Input() gradient: GradientPoint[] = [];\\n\\n  /** Taking input for the radius of the circle and the label to be displayed. */\\n  @Input() sizes: SizeLegend[] = [];\\n\\n  /** Cell id which is hovered, used for highlighting */\\n  @Input() highlightedCellId = \'\';\\n\\n  /** List of cell ids in the illustration */\\n  @Input() illustrationIds: string[] = [];\\n\\n  /** Emits cell type label when row is hovered */\\n  @Output() readonly rowHover = new EventEmitter<string>();\\n\\n  /** Reference to virtual scroll viewport */\\n  @ViewChild(CdkVirtualScrollViewport, { static: true }) vscroll!: CdkVirtualScrollViewport;\\n\\n  /** Reference to biomarker table */\\n  @ViewChild(\'table\', { static: true, read: ElementRef }) table!: ElementRef;\\n\\n  /** Columns replaysubject */\\n  readonly columns$ = new ReplaySubject<string[]>(1);\\n\\n  /** Cell width (px) */\\n  private readonly cellWidth = 44;\\n  /** Extra columns to render outside the visible viewport */\\n  private readonly extraDisplayedColumnCount = 2;\\n\\n  /** Current horizontal viewport size */\\n  private horizontalViewportSize = 400;\\n  /** Current horizontal scroll offset */\\n  private horizontalScrollOffset = 0;\\n  /** Current displayed column count */\\n  private displayedColumnCount = 10;\\n  /** Current displayed column offset */\\n  private displayedColumnOffset = 0;\\n\\n  /** Gets the current width of the prefiller column */\\n  get preFillerWidth(): string {\\n    return `${this.cellWidth * this.displayedColumnOffset}px`;\\n  }\\n\\n  /** Gets the current width of the postfiller column */\\n  get postFillerWidth(): string {\\n    const count = this.columns.length - this.displayedColumnCount - this.displayedColumnOffset;\\n    return `${this.cellWidth * count}px`;\\n  }\\n\\n  /** Source for the table */\\n  readonly dataSource = new TableVirtualScrollDataSource<DataRow<T>>([]);\\n\\n  /** Change detection */\\n  private readonly cdr = inject(ChangeDetectorRef);\\n\\n  /**\\n   * Subscribes to scroll event on virtual scroll viewport and checks displayed columns\\n   */\\n  ngOnInit(): void {\\n    const scroll$ = this.vscroll.scrollable.elementScrolled();\\n    scroll$.subscribe(() => this.checkDisplayedColumns());\\n  }\\n\\n  /**\\n   * Sets the data source for the table on every change\\n   * Sorts the biomarker table on illustrationIds change\\n   * @param changes object consisting of change in the Input\\n   */\\n  ngOnChanges(changes: SimpleChanges): void {\\n    this.checkDisplayedColumns(\'columns\' in changes);\\n    if (\'data\' in changes || \'illustrationIds\' in changes) {\\n      this.dataSource.data = this.sortTableData(this.data);\\n    }\\n  }\\n\\n  /**\\n   * Checks for column updates on mouse move\\n   */\\n  @HostListener(\'window:mousemove\', [\'$event\'])\\n  onMouseMove() {\\n    this.checkDisplayedColumns();\\n  }\\n\\n  /**\\n   * Returns index value\\n   */\\n  trackByIndex(index: number): number {\\n    return index;\\n  }\\n\\n  /**\\n   * Checks to see if columns should be updated\\n   */\\n  checkDisplayedColumns(forceUpdate = false): void {\\n    const scrollable = this.vscroll.scrollable;\\n    const size = scrollable.measureViewportSize(\'horizontal\');\\n    const offset = scrollable.measureScrollOffset(\'start\');\\n    let shouldUpdate = forceUpdate;\\n\\n    if (size !== this.horizontalViewportSize) {\\n      this.updateHorizontalViewportSize(size);\\n      shouldUpdate = true;\\n    }\\n    if (offset !== this.horizontalScrollOffset) {\\n      this.updateHorizontalViewportOffset(offset);\\n      shouldUpdate = true;\\n    }\\n\\n    if (shouldUpdate) {\\n      this.updateColumns();\\n    }\\n  }\\n\\n  /**\\n   * Updates horizontal viewport size and updates displayed column count\\n   */\\n  updateHorizontalViewportSize(size: number): void {\\n    this.horizontalViewportSize = size;\\n    this.displayedColumnCount =\\n      Math.ceil(this.horizontalViewportSize / this.cellWidth) + this.extraDisplayedColumnCount;\\n  }\\n\\n  /**\\n   * Updates horizontal viewport offset and updates displayed column offset\\n   */\\n  updateHorizontalViewportOffset(offset: number): void {\\n    this.horizontalScrollOffset = offset;\\n    this.displayedColumnOffset = Math.max(Math.floor(offset / this.cellWidth) - this.extraDisplayedColumnCount / 2, 0);\\n  }\\n\\n  /**\\n   * Updates table columns with prefiller and postfiller columns\\n   */\\n  updateColumns(): void {\\n    const { displayedColumnCount, displayedColumnOffset } = this;\\n    const columns = [\'type\', \'count\'];\\n    if (this.displayedColumnOffset > 0) {\\n      columns.push(\'preFiller\');\\n    }\\n\\n    const displayedColumns = this.columns.slice(displayedColumnOffset, displayedColumnOffset + displayedColumnCount);\\n    columns.push(...displayedColumns);\\n\\n    if (displayedColumnOffset + displayedColumnCount < this.columns.length) {\\n      columns.push(\'postFiller\');\\n    }\\n\\n    this.columns$.next(columns);\\n    this.cdr.detectChanges();\\n  }\\n\\n  /**\\n   * Sorts table by cell type alphabetically, then puts cells that are in the illustration on top\\n   */\\n  sortTableData(data: DataRow<T>[]): DataRow<T>[] {\\n    const illustrationIdsSet = new Set(this.illustrationIds);\\n    const inIllustration = new Map<DataRow<T>, boolean>();\\n    for (const row of data) {\\n      const id = this.getHoverId(row);\\n      inIllustration.set(row, illustrationIdsSet.has(id));\\n    }\\n\\n    return [...data].sort((row1, row2) => {\\n      const in1 = inIllustration.get(row1);\\n      const in2 = inIllustration.get(row2);\\n\\n      if (in1 && !in2) {\\n        return -1;\\n      } else if (!in1 && in2) {\\n        return 1;\\n      }\\n\\n      return row1[0].localeCompare(row2[0]);\\n    });\\n  }\\n\\n  /**\\n   * Returns true if id matches the cell id of the row\\n   * @param row Highlighted row\\n   */\\n  isHighlighted(row: DataRow<T>): boolean {\\n    return this.getHoverId(row) === this.highlightedCellId;\\n  }\\n\\n  /**\\n   * Gets hover id from row\\n   * @param data row data\\n   * @returns cell type id\\n   */\\n  getHoverId(data: DataRow<T>): string {\\n    const entry = data.slice(2).find((item) => item) as T;\\n    return entry?.data.cell;\\n  }\\n\\n  /** Lerp function to give value beween min and max value based on the given value\\n   *\\n   * @param value\\n   * @param min\\n   * @param max\\n   * @returns\\n   */\\n  lerp(value: number, min: number, max: number): number {\\n    return min * (1 - value) + max * value;\\n  }\\n\\n  /**\\n   * Converts HexCode to RGB\\n   * @param hex\\n   * @returns\\n   */\\n  hex2rgb(hex: string): RGBTriplet {\\n    const r = parseInt(hex.slice(1, 3), 16);\\n    const g = parseInt(hex.slice(3, 5), 16);\\n    const b = parseInt(hex.slice(5, 7), 16);\\n    return [r, g, b];\\n  }\\n\\n  /**\\n   * Gets Min and Max color grade based on the meanExpression value\\n   * @param meanExpression\\n   * @returns\\n   */\\n  getMinMaxColor(meanExpression: number): { minColor: RGBTriplet; maxColor: RGBTriplet } {\\n    const index = this.gradient.findIndex((item, i, arr) => {\\n      return meanExpression >= item.percentage && meanExpression <= arr[i + 1]?.percentage;\\n    });\\n\\n    const minColor: RGBTriplet = this.hex2rgb(this.gradient[index]?.color ?? this.gradient[0].color);\\n    const maxColor: RGBTriplet = this.hex2rgb(this.gradient[index + 1].color);\\n\\n    return { minColor, maxColor };\\n  }\\n\\n  /**\\n   * Gets Min and Max size grade based on the Percentage value\\n   * @param percentage\\n   * @returns\\n   */\\n  getMinMaxSize(percentage: number): { minSize: number; maxSize: number } {\\n    const index = this.sizes.findIndex((item, i, arr) => {\\n      return percentage >= parseFloat(item.label) / 100 && percentage <= parseFloat(arr[i + 1]?.label) / 100;\\n    });\\n    const minSize: number = this.sizes[index]?.radius;\\n    const maxSize: number = this.sizes[index + 1].radius;\\n    return { minSize, maxSize };\\n  }\\n\\n  /**\\n   * Calculates the color of this value on this gradient\\n   * @param value\\n   * @returns\\n   */\\n  getColor(value: number): string {\\n    const { minColor, maxColor } = this.getMinMaxColor(value * 100);\\n    return (\\n      \'#\' +\\n      minColor\\n        .map((min, index) => this.lerp(value, min, maxColor[index]))\\n        .map((component) => {\\n          const hex = Math.round(component).toString(16);\\n          return hex.length === 1 ? \'0\' + hex : hex;\\n        })\\n        .join(\'\')\\n    );\\n  }\\n\\n  /**\\n   * gets Size of the Cell based on the percentage value\\n   * @param value\\n   * @returns\\n   */\\n  getSize(value: number): number {\\n    const { minSize, maxSize } = this.getMinMaxSize(value);\\n    return this.lerp(value, minSize, maxSize);\\n  }\\n\\n  /**\\n   * Processes the object for hover data for Table Cell\\n   * @param index index of the row of the datasource\\n   * @param row row of the datasource\\n   * @returns\\n   */\\n  getHoverData([index, row]: [number, DataRow<T>]): DataItem[][] {\\n    if (row[index] === undefined) {\\n      return [];\\n    }\\n\\n    const {\\n      tissueInfo: { id, label },\\n    } = this;\\n    const {\\n      data: { cell, biomarker, meanExpression, dataset_count },\\n    } = row[index] as T;\\n\\n    return [\\n      [\\n        { label: \'Functional Tissue Unit Name\', value: label },\\n        { label: \'Uberon ID\', value: id },\\n        { label: \'#Datasets\', value: `${dataset_count ?? 0}` },\\n      ],\\n      [\\n        { label: \'Cell Type Name\', value: row[0] },\\n        { label: \'CL ID\', value: cell },\\n        { label: \'Number of Cells\', value: `${row[1]}` },\\n      ],\\n      [\\n        { label: \'Gene Name\', value: this.columns[index - 2] },\\n        { label: \'HGNC ID\', value: biomarker },\\n        { label: \'Mean Expression Value\', value: meanExpression.toFixed(6) },\\n      ],\\n    ];\\n  }\\n\\n  /**\\n   * Sets and emits cell type id on row hover\\n   * @param hoverId cell type id\\n   */\\n  setHoverId(hoverId?: string): void {\\n    this.highlightedCellId = hoverId ?? \'\';\\n    this.rowHover.emit(hoverId);\\n  }\\n}\\n","assetsDirs":[],"styleUrlsData":[{"data":"@use \'utils\';\\n@use \'variables\' as vars;\\n\\n:host {\\n  display: block;\\n\\n  .table th,\\n  .table th div {\\n    height: 6.5rem !important;\\n  }\\n\\n  cdk-virtual-scroll-viewport {\\n    height: 100%;\\n  }\\n\\n  .sr-only {\\n    @include utils.sr-only();\\n  }\\n\\n  .table {\\n    margin-left: -1px;\\n\\n    .highlight {\\n      background: rgba(vars.$primary-lighter);\\n    }\\n    td.type {\\n      text-transform: lowercase;\\n    }\\n  }\\n\\n  .table th {\\n    background: rgba(vars.$primary-lighter);\\n    color: rgba(vars.$accent-darker);\\n    font-weight: 500;\\n    height: 56px;\\n    padding: 0;\\n    max-width: 2.75rem;\\n    min-width: 2.75rem;\\n    border-bottom: 1px solid rgba(vars.$light-dividers);\\n  }\\n\\n  .table td {\\n    border-bottom: 1px solid rgba(vars.$light-dividers);\\n    padding: 0 0.5rem;\\n\\n    &:not(:first-child) {\\n      border-left: 1px solid rgba(vars.$light-dividers);\\n    }\\n  }\\n\\n  .table tr {\\n    height: 2rem;\\n    font-size: 0.75rem;\\n  }\\n\\n  .table tr:first-child td {\\n    border-top: 0rem solid rgba(vars.$light-dividers);\\n    max-width: 13.5rem;\\n  }\\n\\n  tr > td:first-child {\\n    text-align: left;\\n  }\\n\\n  tr > th:first-child {\\n    text-align: left;\\n  }\\n\\n  tr > td:last-of-type {\\n    border-right: 1px solid rgba(vars.$light-dividers);\\n  }\\n\\n  tr > th:last-of-type {\\n    border-right: 1px solid rgba(vars.$light-dividers);\\n    border-left: 1px solid rgba(vars.$light-dividers);\\n  }\\n\\n  .type {\\n    height: 2rem;\\n    max-width: 13.5rem;\\n    border-radius: 0rem;\\n    white-space: nowrap;\\n\\n    &.highlight {\\n      font-weight: bold;\\n    }\\n  }\\n\\n  .count {\\n    height: 2rem;\\n    min-width: 4.25rem;\\n    border-right: 1px solid rgba(vars.$light-dividers);\\n  }\\n\\n  th:not(:first-child) {\\n    border-left: 1px solid rgba(vars.$light-dividers);\\n  }\\n\\n  th:first-child,\\n  th:nth-child(2) {\\n    padding: 0 0.5rem !important;\\n  }\\n\\n  .icon-header {\\n    .header-column-text {\\n      // transform: rotate(-90deg);\\n      writing-mode: vertical-rl;\\n      transform: rotate(180deg);\\n      white-space: nowrap;\\n      overflow: hidden;\\n      text-overflow: ellipsis;\\n      margin: 0.5rem auto;\\n    }\\n  }\\n\\n  .icon-cell {\\n    width: 2rem;\\n    min-height: 2rem;\\n\\n    .icon {\\n      margin: auto;\\n    }\\n  }\\n}\\n\\n.mat-mdc-row:hover .mat-mdc-cell {\\n  background: rgba(vars.$primary-lighter);\\n}\\n","styleUrl":"./biomarker-table.component.scss"}],"stylesData":"","extends":[],"implements":["OnInit","OnChanges"],"accessors":{"preFillerWidth":{"name":"preFillerWidth","getSignature":{"name":"preFillerWidth","type":"string","returnType":"string","line":142,"rawdescription":"\\nGets the current width of the prefiller column","description":"<p>Gets the current width of the prefiller column</p>\\n"}},"postFillerWidth":{"name":"postFillerWidth","getSignature":{"name":"postFillerWidth","type":"string","returnType":"string","line":147,"rawdescription":"\\nGets the current width of the postfiller column","description":"<p>Gets the current width of the postfiller column</p>\\n"}}},"templateData":"<cdk-virtual-scroll-viewport tvsItemSize=\\"32\\" headerHeight=\\"72\\">\\n  <table class=\\"table\\" mat-table [dataSource]=\\"dataSource\\" #table>\\n    <caption class=\\"sr-only\\">\\n      Cell type table by Biomarker\\n    </caption>\\n\\n    <ng-container matColumnDef=\\"type\\" sticky>\\n      <th mat-header-cell *matHeaderCellDef>Cell Type</th>\\n\\n      <td\\n        class=\\"type\\"\\n        mat-cell\\n        *matCellDef=\\"let element\\"\\n        [class.highlight]=\\"isHighlighted(element)\\"\\n        [hraHover]=\\"columnHover\\"\\n        [hraHoverData]=\\"element[0]\\"\\n      >\\n        {{ element[0] }}\\n      </td>\\n    </ng-container>\\n\\n    <ng-container matColumnDef=\\"count\\" sticky>\\n      <th class=\\"count\\" mat-header-cell *matHeaderCellDef>Cell Count</th>\\n\\n      <td class=\\"count\\" mat-cell *matCellDef=\\"let element\\" [class.highlight]=\\"isHighlighted(element)\\">\\n        {{ element[1] !== undefined ? (element[1] | number) : \'no data\' }}\\n      </td>\\n    </ng-container>\\n\\n    <ng-container matColumnDef=\\"preFiller\\">\\n      <th mat-header-cell *matHeaderCellDef></th>\\n      <td mat-cell *matCellDef=\\"let element\\" style=\\"max-width: unset\\">\\n        <div [style.width]=\\"preFillerWidth\\"></div>\\n      </td>\\n    </ng-container>\\n\\n    <ng-container *ngFor=\\"let column of columns; let index = index; trackBy: trackByIndex\\" [matColumnDef]=\\"column\\">\\n      <th class=\\"icon-header\\" mat-header-cell *matHeaderCellDef [hraHover]=\\"columnHover\\" [hraHoverData]=\\"column\\">\\n        <div class=\\"header-column-text\\">\\n          {{ column }}\\n        </div>\\n      </th>\\n\\n      <td class=\\"icon-cell\\" mat-cell *matCellDef=\\"let element\\" [class.highlight]=\\"isHighlighted(element)\\">\\n        <hra-biomarker-table-data-icon\\n          class=\\"icon\\"\\n          *ngIf=\\"element[index + 2] !== undefined; else emptyCell\\"\\n          [color]=\\"getColor(element[index + 2].color)\\"\\n          [size]=\\"getSize(element[index + 2].size)\\"\\n          [hraHover]=\\"dataHover\\"\\n          [hraHoverData]=\\"[index + 2, element]\\"\\n        >\\n        </hra-biomarker-table-data-icon>\\n\\n        <ng-template #emptyCell>\\n          <div class=\\"empty\\" [hraHover]=\\"dataHover\\" [hraHoverData]=\\"[index + 2, element]\\"></div>\\n        </ng-template>\\n      </td>\\n    </ng-container>\\n\\n    <ng-container matColumnDef=\\"postFiller\\">\\n      <th mat-header-cell *matHeaderCellDef></th>\\n      <td mat-cell *matCellDef=\\"let element\\" style=\\"max-width: unset\\">\\n        <div [style.width]=\\"postFillerWidth\\"></div>\\n      </td>\\n    </ng-container>\\n\\n    <tr mat-header-row *matHeaderRowDef=\\"(columns$ | async) ?? []; sticky: true\\"></tr>\\n    <tr\\n      mat-row\\n      *matRowDef=\\"let row; columns: (columns$ | async) ?? []\\"\\n      (mouseover)=\\"setHoverId(getHoverId(row))\\"\\n      (mouseout)=\\"setHoverId(undefined)\\"\\n    ></tr>\\n  </table>\\n</cdk-virtual-scroll-viewport>\\n\\n<ng-template #columnHover let-columnName>\\n  <div class=\\"biomarker-table-hover full-column-name\\">\\n    {{ columnName }}\\n  </div>\\n</ng-template>\\n\\n<ng-template #dataHover let-data>\\n  <hra-biomarker-table-data-card [data]=\\"getHoverData(data)\\"> </hra-biomarker-table-data-card>\\n</ng-template>\\n"}],"modules":[],"miscellaneous":{"variables":[{"name":"Primary","ctype":"miscellaneous","subtype":"variable","file":"libs/components/organisms/src/lib/biomarker-table/biomarker-table.component.stories.ts","deprecated":false,"deprecationMessage":"","type":"object","defaultValue":"{\\n  render: Template,\\n\\n  args: {\\n    columns: [\'RGMB\', \'SOX9\', \'CD44\', \'LGR5\', \'chromosome inavalitentte A\'],\\n    tissueInfo: { id: \'555\', label: \'sampleDataset\' },\\n    data: [\\n      [\\n        \'absorptive cell\',\\n        2764,\\n        {\\n          color: \'#9ca5ee\',\\n          size: 0.56,\\n          data: {\\n            cell: \'\',\\n            biomarker: \'\',\\n            meanExpression: 0,\\n            dataset_count: 0,\\n          },\\n        },\\n      ],\\n      [\\n        \'enteroendocrine cell\',\\n        17,\\n        {\\n          color: \'#00ffb2\',\\n          size: 0.689,\\n          data: {\\n            cell: \'\',\\n            biomarker: \'\',\\n            meanExpression: 0,\\n            dataset_count: 0,\\n          },\\n        },\\n      ],\\n      [\\n        \'epithelial stem cell\',\\n        187,\\n        {\\n          color: \'#00ffb2\',\\n          size: 0.689,\\n          data: {\\n            cell: \'\',\\n            biomarker: \'\',\\n            meanExpression: 0,\\n            dataset_count: 0,\\n          },\\n        },\\n      ],\\n      [\\n        \'goblet cell\',\\n        187,\\n        {\\n          color: \'#00ffb2\',\\n          size: 0.689,\\n          data: {\\n            cell: \'\',\\n            biomarker: \'\',\\n            meanExpression: 0,\\n            dataset_count: 0,\\n          },\\n        },\\n      ],\\n    ],\\n  },\\n}"},{"name":"Template","ctype":"miscellaneous","subtype":"variable","file":"libs/components/organisms/src/lib/biomarker-table/biomarker-table.component.stories.ts","deprecated":false,"deprecationMessage":"","type":"StoryFn<BiomarkerTableComponent<DataCell>>","defaultValue":"(args) => ({\\n  props: args,\\n})"}],"functions":[],"typealiases":[{"name":"DataRow","ctype":"miscellaneous","subtype":"typealias","rawtype":"[string, , ...[]]","file":"libs/components/organisms/src/lib/biomarker-table/biomarker-table.component.ts","deprecated":false,"deprecationMessage":"","description":"<p>Describes the composition of a single row in the table</p>\\n","kind":189},{"name":"RGBTriplet","ctype":"miscellaneous","subtype":"typealias","rawtype":"[number, number, number]","file":"libs/components/organisms/src/lib/biomarker-table/biomarker-table.component.ts","deprecated":false,"deprecationMessage":"","description":"<p>RGBTriblet of type RGB to store color</p>\\n","kind":189}],"enumerations":[],"groupedVariables":{"libs/components/organisms/src/lib/biomarker-table/biomarker-table.component.stories.ts":[{"name":"Primary","ctype":"miscellaneous","subtype":"variable","file":"libs/components/organisms/src/lib/biomarker-table/biomarker-table.component.stories.ts","deprecated":false,"deprecationMessage":"","type":"object","defaultValue":"{\\n  render: Template,\\n\\n  args: {\\n    columns: [\'RGMB\', \'SOX9\', \'CD44\', \'LGR5\', \'chromosome inavalitentte A\'],\\n    tissueInfo: { id: \'555\', label: \'sampleDataset\' },\\n    data: [\\n      [\\n        \'absorptive cell\',\\n        2764,\\n        {\\n          color: \'#9ca5ee\',\\n          size: 0.56,\\n          data: {\\n            cell: \'\',\\n            biomarker: \'\',\\n            meanExpression: 0,\\n            dataset_count: 0,\\n          },\\n        },\\n      ],\\n      [\\n        \'enteroendocrine cell\',\\n        17,\\n        {\\n          color: \'#00ffb2\',\\n          size: 0.689,\\n          data: {\\n            cell: \'\',\\n            biomarker: \'\',\\n            meanExpression: 0,\\n            dataset_count: 0,\\n          },\\n        },\\n      ],\\n      [\\n        \'epithelial stem cell\',\\n        187,\\n        {\\n          color: \'#00ffb2\',\\n          size: 0.689,\\n          data: {\\n            cell: \'\',\\n            biomarker: \'\',\\n            meanExpression: 0,\\n            dataset_count: 0,\\n          },\\n        },\\n      ],\\n      [\\n        \'goblet cell\',\\n        187,\\n        {\\n          color: \'#00ffb2\',\\n          size: 0.689,\\n          data: {\\n            cell: \'\',\\n            biomarker: \'\',\\n            meanExpression: 0,\\n            dataset_count: 0,\\n          },\\n        },\\n      ],\\n    ],\\n  },\\n}"},{"name":"Template","ctype":"miscellaneous","subtype":"variable","file":"libs/components/organisms/src/lib/biomarker-table/biomarker-table.component.stories.ts","deprecated":false,"deprecationMessage":"","type":"StoryFn<BiomarkerTableComponent<DataCell>>","defaultValue":"(args) => ({\\n  props: args,\\n})"}]},"groupedFunctions":{},"groupedEnumerations":{},"groupedTypeAliases":{"libs/components/organisms/src/lib/biomarker-table/biomarker-table.component.ts":[{"name":"DataRow","ctype":"miscellaneous","subtype":"typealias","rawtype":"[string, , ...[]]","file":"libs/components/organisms/src/lib/biomarker-table/biomarker-table.component.ts","deprecated":false,"deprecationMessage":"","description":"<p>Describes the composition of a single row in the table</p>\\n","kind":189},{"name":"RGBTriplet","ctype":"miscellaneous","subtype":"typealias","rawtype":"[number, number, number]","file":"libs/components/organisms/src/lib/biomarker-table/biomarker-table.component.ts","deprecated":false,"deprecationMessage":"","description":"<p>RGBTriblet of type RGB to store color</p>\\n","kind":189}]}},"routes":[],"coverage":{"count":71,"status":"good","files":[{"filePath":"libs/components/organisms/src/lib/biomarker-table/biomarker-table.component.stories.ts","type":"variable","linktype":"miscellaneous","linksubtype":"variable","name":"Primary","coveragePercent":0,"coverageCount":"0/1","status":"low"},{"filePath":"libs/components/organisms/src/lib/biomarker-table/biomarker-table.component.stories.ts","type":"variable","linktype":"miscellaneous","linksubtype":"variable","name":"Template","coveragePercent":0,"coverageCount":"0/1","status":"low"},{"filePath":"libs/components/organisms/src/lib/biomarker-table/biomarker-table.component.ts","type":"component","linktype":"component","name":"BiomarkerTableComponent","coveragePercent":100,"coverageCount":"41/41","status":"very-good"},{"filePath":"libs/components/organisms/src/lib/biomarker-table/biomarker-table.component.ts","type":"interface","linktype":"interface","name":"DataCell","coveragePercent":100,"coverageCount":"4/4","status":"very-good"},{"filePath":"libs/components/organisms/src/lib/biomarker-table/biomarker-table.component.ts","type":"interface","linktype":"interface","name":"TissueInfo","coveragePercent":100,"coverageCount":"3/3","status":"very-good"},{"filePath":"libs/components/organisms/src/lib/biomarker-table/biomarker-table.component.ts","type":"type alias","linktype":"miscellaneous","linksubtype":"typealias","name":"DataRow","coveragePercent":100,"coverageCount":"1/1","status":"very-good"},{"filePath":"libs/components/organisms/src/lib/biomarker-table/biomarker-table.component.ts","type":"type alias","linktype":"miscellaneous","linksubtype":"typealias","name":"RGBTriplet","coveragePercent":100,"coverageCount":"1/1","status":"very-good"}]}}');var http=__webpack_require__("./node_modules/@angular/common/fesm2022/http.mjs"),core=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),animations=__webpack_require__("./node_modules/@angular/platform-browser/fesm2022/animations.mjs"),ngxs_logger_plugin=__webpack_require__("./node_modules/@ngxs/logger-plugin/fesm2022/ngxs-logger-plugin.mjs"),ngxs_store=__webpack_require__("./node_modules/@ngxs/store/fesm2022/ngxs-store.mjs"),dist=__webpack_require__("./node_modules/@storybook/angular/dist/index.mjs"),ngx_markdown=__webpack_require__("./node_modules/ngx-markdown/fesm2022/ngx-markdown.mjs"),tslib_es6=__webpack_require__("./node_modules/tslib/tslib.es6.mjs"),angular_material_css_vars=__webpack_require__("./node_modules/angular-material-css-vars/fesm2022/angular-material-css-vars.mjs"),js_yaml=__webpack_require__("./node_modules/js-yaml/dist/js-yaml.mjs"),map=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/map.js"),tap=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/tap.js"),Observable=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/Observable.js");class Load{static{this.type="[Theming] Load Theming File"}constructor(url){this.url=url,this.type=Load.type}}var lib=__webpack_require__("./node_modules/zod/lib/index.mjs");const THEMING_FILE_SCHEMA=lib.z.record(lib.z.nativeEnum(angular_material_css_vars.GC),lib.z.string());let ThemingState=class ThemingState{constructor(){this.http=(0,core.inject)(http.Qq),this.materialVars=(0,core.inject)(angular_material_css_vars.EH)}load(ctx,{url}){return this.http.get(url,{responseType:"text"}).pipe((0,map.T)((data=>(0,js_yaml.Hh)(data,{filename:url}))),(0,map.T)((data=>THEMING_FILE_SCHEMA.parse(data))),(0,tap.M)((data=>ctx.setState(data))),(0,tap.M)((data=>this.setVariables(data))))}setVariables(data){for(const[key,value]of Object.entries(data))this.materialVars.setVariable(key,value)}};(0,tslib_es6.Cg)([(0,ngxs_store.rc)(Load),(0,tslib_es6.Sn)("design:type",Function),(0,tslib_es6.Sn)("design:paramtypes",[Object,Load]),(0,tslib_es6.Sn)("design:returntype",Observable.c)],ThemingState.prototype,"load",null),ThemingState=(0,tslib_es6.Cg)([(0,ngxs_store.Uw)({name:"theming",defaults:{}}),(0,core.Injectable)()],ThemingState);let ThemingModule=class ThemingModule{};function parseDefaultValue(type){const{defaultValue,type:typeDef}=type;if(void 0===defaultValue||"string"!=typeof defaultValue||"string"===typeDef?.name)return defaultValue;switch(typeDef?.name){case"array":case"boolean":case"number":case"object":try{return new Function("return "+defaultValue)()}catch(_error){return}case"enum":return typeDef.value.includes(defaultValue)?defaultValue:void 0;default:return}}ThemingModule=(0,tslib_es6.Cg)([(0,core.NgModule)({imports:[angular_material_css_vars.tY.forRoot({}),ngxs_store.rK.forFeature([ThemingState])]})],ThemingModule);const parameters={actions:{argTypesRegex:"^on[A-Z].*"},controls:{matchers:{color:/(background|color)$/i,date:/Date$/}},docs:{inlineStories:!0}},argTypesEnhancers=[function fixArgTypes(){return context=>{const argTypes={...context.argTypes},exclude=[...context.parameters.controls?.exclude??[]];for(const[key,type]of Object.entries(argTypes))switch(type.table?.category){case"inputs":const defaultValue=parseDefaultValue(type);defaultValue!==type.defaultValue&&(argTypes[key]={...type,defaultValue});break;case"outputs":argTypes[key]={...type,defaultValue:void 0};break;default:exclude.push(key)}return context.parameters.controls={...context.parameters.controls,exclude},argTypes}}()],decorators=[(0,dist.applicationConfig)({providers:[(0,core.importProvidersFrom)(animations.BrowserAnimationsModule,http.q1,ngxs_store.rK.forRoot([],{developmentMode:!0}),ngxs_logger_plugin.i_.forRoot(),ngx_markdown.y2.forRoot({loader:http.Qq}),ThemingModule)]}),(0,dist.componentWrapperDecorator)((story=>`\n      <div class="mat-typography">${story}</div>\n      <div class="backdrop-filler" style="position: absolute; inset: 0; z-index: -1;"></div>\n    `)),function addState(){return(fn,ctx)=>{const config=ctx.parameters.state;return config?(0,dist.applicationConfig)({providers:[(0,core.importProvidersFrom)(ngxs_store.rK.forFeature(config.states)),{provide:core.APP_INITIALIZER,multi:!0,useFactory:store=>()=>{const{actions}=config;return actions&&actions.length>0?store.dispatch(actions):void 0},deps:[ngxs_store.il]}]})(fn,ctx):fn(ctx)}}()];(0,angular.$)(documentation_namespaceObject)},"./node_modules/memoizerific sync recursive":module=>{function webpackEmptyContext(req){var e=new Error("Cannot find module '"+req+"'");throw e.code="MODULE_NOT_FOUND",e}webpackEmptyContext.keys=()=>[],webpackEmptyContext.resolve=webpackEmptyContext,webpackEmptyContext.id="./node_modules/memoizerific sync recursive",module.exports=webpackEmptyContext},"./storybook-config-entry.js":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";var external_STORYBOOK_MODULE_CHANNELS_=__webpack_require__("storybook/internal/channels"),csf=__webpack_require__("./node_modules/@storybook/core/dist/csf/index.js"),external_STORYBOOK_MODULE_PREVIEW_API_=__webpack_require__("storybook/internal/preview-api"),external_STORYBOOK_MODULE_GLOBAL_=__webpack_require__("@storybook/global"),asyncToGenerator=__webpack_require__("./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");const importers=[function(){var _ref=(0,asyncToGenerator.A)((function*(path){if(!/^\.[\\/](?:libs\/components\/organisms(?:\/(?!\.)(?:(?:(?!(?:^|\/)\.).)*?)\/|\/|$)(?!\.)(?=.)[^/]*?\.mdx)$/.exec(path))return;const pathRemainder=path.substring(28);return __webpack_require__("./libs/components/organisms lazy recursive ^\\.\\/.*$ include: (?%21.*node_modules)(?:\\/libs\\/components\\/organisms(?:\\/(?%21\\.)(?:(?:(?%21(?:^%7C\\/)\\.).)*?)\\/%7C\\/%7C$)(?%21\\.)(?=.)[^/]*?\\.mdx)$")("./"+pathRemainder)}));return function(_x){return _ref.apply(this,arguments)}}(),function(){var _ref2=(0,asyncToGenerator.A)((function*(path){if(!/^\.[\\/](?:libs\/components\/organisms(?:\/(?!\.)(?:(?:(?!(?:^|\/)\.).)*?)\/|\/|$)(?!\.)(?=.)[^/]*?\.stories\.(js|jsx|ts|tsx))$/.exec(path))return;const pathRemainder=path.substring(28);return __webpack_require__("./libs/components/organisms lazy recursive ^\\.\\/.*$ include: (?%21.*node_modules)(?:\\/libs\\/components\\/organisms(?:\\/(?%21\\.)(?:(?:(?%21(?:^%7C\\/)\\.).)*?)\\/%7C\\/%7C$)(?%21\\.)(?=.)[^/]*?\\.stories\\.(js%7Cjsx%7Cts%7Ctsx))$")("./"+pathRemainder)}));return function(_x2){return _ref2.apply(this,arguments)}}()];function _importFn(){return(_importFn=(0,asyncToGenerator.A)((function*(path){for(let i=0;i<importers.length;i++){const moduleExports=yield(x=()=>importers[i](path),x());if(moduleExports)return moduleExports}var x}))).apply(this,arguments)}const channel=(0,external_STORYBOOK_MODULE_CHANNELS_.createBrowserChannel)({page:"preview"});external_STORYBOOK_MODULE_PREVIEW_API_.addons.setChannel(channel),"DEVELOPMENT"===external_STORYBOOK_MODULE_GLOBAL_.global.CONFIG_TYPE&&(window.__STORYBOOK_SERVER_CHANNEL__=channel);const preview=new external_STORYBOOK_MODULE_PREVIEW_API_.PreviewWeb((function importFn(_x3){return _importFn.apply(this,arguments)}),(()=>{const previewAnnotations=[__webpack_require__("./node_modules/@storybook/angular/dist/client/preview-prod.js"),__webpack_require__("./node_modules/@storybook/angular/dist/client/docs/config.js"),__webpack_require__("./node_modules/@storybook/angular/dist/client/config.js"),__webpack_require__("./node_modules/@storybook/addon-essentials/dist/actions/preview.mjs"),__webpack_require__("./node_modules/@storybook/addon-essentials/dist/docs/preview.mjs"),__webpack_require__("./node_modules/@storybook/addon-essentials/dist/backgrounds/preview.mjs"),__webpack_require__("./node_modules/@storybook/addon-essentials/dist/viewport/preview.mjs"),__webpack_require__("./node_modules/@storybook/addon-essentials/dist/measure/preview.mjs"),__webpack_require__("./node_modules/@storybook/addon-essentials/dist/outline/preview.mjs"),__webpack_require__("./node_modules/@storybook/addon-essentials/dist/highlight/preview.mjs"),__webpack_require__("./libs/components/organisms/.storybook/preview.ts")],userPreview=previewAnnotations[previewAnnotations.length-1]?.default;return(0,csf.bU)(userPreview)?userPreview.composed:(0,external_STORYBOOK_MODULE_PREVIEW_API_.composeConfigs)(previewAnnotations)}));window.__STORYBOOK_PREVIEW__=preview,window.__STORYBOOK_STORY_STORE__=preview.storyStore,window.__STORYBOOK_ADDONS_CHANNEL__=channel},"@storybook/global":module=>{"use strict";module.exports=__STORYBOOK_MODULE_GLOBAL__},"storybook/internal/channels":module=>{"use strict";module.exports=__STORYBOOK_MODULE_CHANNELS__},"storybook/internal/client-logger":module=>{"use strict";module.exports=__STORYBOOK_MODULE_CLIENT_LOGGER__},"storybook/internal/core-events":module=>{"use strict";module.exports=__STORYBOOK_MODULE_CORE_EVENTS__},"storybook/internal/preview-api":module=>{"use strict";module.exports=__STORYBOOK_MODULE_PREVIEW_API__},"storybook/internal/preview-errors":module=>{"use strict";module.exports=__STORYBOOK_MODULE_CORE_EVENTS_PREVIEW_ERRORS__}},__webpack_require__=>{var __webpack_exec__=moduleId=>__webpack_require__(__webpack_require__.s=moduleId);__webpack_require__.O(0,[384],(()=>(__webpack_exec__("./storybook-config-entry.js"),__webpack_exec__("./node_modules/@angular/compiler/fesm2022/compiler.mjs"))));__webpack_require__.O()}]);